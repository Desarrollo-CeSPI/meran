/*
 * Meran - MERAN UNLP is a ILS (Integrated Library System) wich provides Catalog,
 * Circulation and User's Management. It's written in Perl, and uses Apache2
 * Web-Server, MySQL database and Sphinx 2 indexing.
 * Copyright (C) 2009-2013 Grupo de desarrollo de Meran CeSPI-UNLP
 *
 * This file is part of Meran.
 *
 * Meran is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Meran is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Meran.  If not, see <http://www.gnu.org/licenses/>.
 */

// sample on how to use the parser and walker API to instrument some code

var jsp = require("uglify-js").parser;
var pro = require("uglify-js").uglify;

function instrument(code) {
        var ast = jsp.parse(code, false, true); // true for the third arg specifies that we want
                                                // to have start/end tokens embedded in the
                                                // statements
        var w = pro.ast_walker();

        // we're gonna need this to push elements that we're currently looking at, to avoid
        // endless recursion.
        var analyzing = [];
        function do_stat() {
                var ret;
                if (this[0].start && analyzing.indexOf(this) < 0) {
                        // without the `analyzing' hack, w.walk(this) would re-enter here leading
                        // to infinite recursion
                        analyzing.push(this);
                        ret = [ "splice", // XXX: "block" is safer
                                [ [ "stat",
                                    [ "call", [ "name", "trace" ],
                                      [ [ "string", this[0].toString() ],
                                        [ "num", this[0].start.line ],
                                        [ "num", this[0].start.col ],
                                        [ "num", this[0].end.line ],
                                        [ "num", this[0].end.col ]]]],
                                  w.walk(this) ]];
                        analyzing.pop(this);
                }
                return ret;
        };
        var new_ast = w.with_walkers({
                "stat"     : do_stat,
                "label"    : do_stat,
                "break"    : do_stat,
                "continue" : do_stat,
                "debugger" : do_stat,
                "var"      : do_stat,
                "const"    : do_stat,
                "return"   : do_stat,
                "throw"    : do_stat,
                "try"      : do_stat,
                "defun"    : do_stat,
                "if"       : do_stat,
                "while"    : do_stat,
                "do"       : do_stat,
                "for"      : do_stat,
                "for-in"   : do_stat,
                "switch"   : do_stat,
                "with"     : do_stat
        }, function(){
                return w.walk(ast);
        });
        return pro.gen_code(new_ast, { beautify: true });
}




////// test code follows.

var code = instrument(test.toString());
console.log(code);

function test() {
        // simple stats
        a = 5;
        c += a + b;
        "foo";

        // var
        var foo = 5;
        const bar = 6, baz = 7;

        // switch block.  note we can't track case lines the same way.
        switch ("foo") {
            case "foo":
                return 1;
            case "bar":
                return 2;
        }

        // for/for in
        for (var i = 0; i < 5; ++i) {
                console.log("Hello " + i);
        }
        for (var i in [ 1, 2, 3]) {
                console.log(i);
        }

        // note however that the following is broken.  I guess we
        // should add the block brackets in this case...
        for (var i = 0; i < 5; ++i)
                console.log("foo");
}
